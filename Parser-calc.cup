package calculator;


import java.util.TreeMap;
import java.util.Map;



parser code {:

    
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
		m.append (info.toString());
        m.append(" : "+message);
        System.err.println(m.toString());
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

	private Map<String, Integer> values = new TreeMap<String, Integer> ();

	public void setValue (String name, int value) {
		values.put(name, Integer.valueOf (value));
	}
	
	public int getValue (String name) {
		int value = 0;
		if (values.containsKey(name))
			value = values.get(name).intValue();
		return value;
	}


:}

terminal  EOLN, UNARIES, __REGEXP_19__, __REGEXP_20__, __REGEXP_21__, __REGEXP_22__, __REGEXP_23__, __REGEXP_24__, __REGEXP_25__;
terminal Integer NUMBER;
terminal String ID;

nonterminal  command, instr, list;
nonterminal Integer expr;

precedence left __REGEXP_19__, __REGEXP_20__;
precedence left __REGEXP_21__, __REGEXP_22__;
precedence right UNARIES;


start with command;

command	::=	list 
		;

expr	::=	expr:e1 __REGEXP_19__ expr:e2 {:  RESULT = e1 + e2;  :} 
		|	expr:e1 __REGEXP_20__ expr:e2 {:  RESULT = e1 - e2;  :} 
		|	expr:e1 __REGEXP_21__ expr:e2 {:  RESULT = e1 * e2;  :} 
		|	expr:e1 __REGEXP_22__ expr:e2 {:  RESULT = e1 / e2;  :} 
		|	__REGEXP_20__ expr:e {:  RESULT = - e;  :}  %prec UNARIES
		|	__REGEXP_19__ expr:e {:  RESULT = + e;  :}  %prec UNARIES
		|	__REGEXP_24__ expr:e __REGEXP_25__ {:  RESULT = e;  :} 
		|	NUMBER:n {:  RESULT = n;  :} 
		|	ID:n {:  RESULT = parser.getValue(n);  :} 
		;

instr	::=	ID:n __REGEXP_23__ expr:e {:  parser.setValue (n, e);  :} 
		|	expr:e {:  System.out.println (e);  :} 
		;

list	::=	( instr EOLN  ) * 
		;

